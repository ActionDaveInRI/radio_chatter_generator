<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Radio Chatter – Environment, Day/Night & Refined Chain Replies</title>
  <style>
    body {
      font-family: monospace;
      background-color: #111;
      color: #0f0;
      padding: 20px;
    }
    h1 { text-align: center; margin-bottom: 20px; }
    #controls { text-align: center; margin-bottom: 20px; }
    button, input[type="range"] {
      padding: 10px 15px; margin: 5px; font-size: 1rem; cursor: pointer;
    }
    #log {
      border: 1px solid #0f0; padding: 10px; height: 300px;
      overflow-y: auto; background-color: #000;
    }
    #log p { margin: 5px 0; }
    #status { text-align: center; margin-top: 10px; font-style: italic; }
    .control-label { margin-right: 10px; }
    /* Custom colors for specific characters */
    .log-Alpha { color: cyan; }
    .log-Bravo { color: #FFBF00; }
  </style>
</head>
<body>
  <h1>Radio Chatter – Environment, Day/Night & Refined Chain Replies</h1>
  <div id="controls">
    <button id="startSim">Start Simulation</button>
    <button id="stopSim">Stop Simulation</button>
    <button id="clearLog">Clear Log</button>
    <label class="control-label" for="delayMultiplier">Delay Multiplier:</label>
    <input type="range" id="delayMultiplier" min="0.5" max="3.0" step="0.1" value="1.0">
    <span id="multiplierValue">1.0</span>
  </div>
  <div id="log"></div>
  <div id="status"></div>
  
  <script>
    /***********************
     * Update Status Function
     ***********************/
    function updateStatus(message) {
      document.getElementById('status').textContent = message;
    }
    
    /***********************
     * Global Variables
     ***********************/
    let simulationRunning = false;
    let audioCtx;
    let basicNoiseSource = null;
    let advancedNoiseSource = null;
    let lfo = null;
    let availableVoices = [];
    let burstInterferenceTimer = null;  // Timer for burst interference
    let lastMessage = null;             // For linking transmissions
    let activeConversation = null;      // { topic, count, lastSpeaker }
    let environmentCondition = "clear";
    let lastEventInfluence = null;      // Recent event influence on mood
    let timeOfDay = "day";              // Day/Night cycle variable
    
    // Chain-related globals:
    let unusualChainState = null;       // For unusual chain responses ("query" or "explanation")
    let triggeredChain = false;         // Flag for trigger-based chain (e.g., urgent messages)
    let chainCounter = 0;               // Counter for triggered chain depth
    const maxChainDepth = 3;            // Maximum depth for triggered chains
    let banterChainActive = false;      // Flag for banter chain (casual, amusing replies)
    let banterChainCounter = 0;         // Counter for banter chain depth
    const maxBanterChainDepth = 3;      // Maximum depth for banter chains
    
    /***********************
     * Template Arrays for Chains
     ***********************/
    // Unusual chain templates – expanded with additional assets.
    const unusualQueries = [
      "What exactly is unusual?",
      "Can you explain what seems off?",
      "What do you mean by unusual?",
      "Why do you say it's unusual?",
      "What on earth is off about that?",
      "Is that really out of the ordinary?"
    ];
    const unusualExplanations = [
      "It appears there are some anomalies.",
      "There are signals that don't match our normal readings.",
      "The data seems irregular.",
      "There is a deviation from the norm.",
      "Our sensors are throwing us a curveball.",
      "Maybe it's just a fleeting glitch."
    ];
    
    // Triggered chain templates for urgent triggers.
    const triggeredChainQueries = [
      "What's the urgent situation?",
      "What is the emergency exactly?",
      "Give me the critical update!",
      "What's causing this alert?"
    ];
    const triggeredChainExplanations = [
      "We're experiencing a significant anomaly.",
      "The situation is dire.",
      "There's a critical breakdown in the system.",
      "Urgent intervention may be required."
    ];
    
    // Banter chain templates for casual, amusing replies.
    const banterChainQueries = [
      "Really? That's hilarious—what happened next?",
      "Are you serious? Tell me more!",
      "That sounds wild! Can you elaborate?",
      "Seriously, what did you see?"
    ];
    const banterChainExplanations = [
      "I know, right? It's just too funny!",
      "Absolutely, it's a riot!",
      "I'm still laughing about that one!",
      "Totally, it's a real laugh!"
    ];
    
    /***********************
     * Trigger Keyword System
     ***********************/
    const triggerKeywords = ["urgent", "alert", "critical"];
    function checkForTrigger(text) {
      const lower = text.toLowerCase();
      return triggerKeywords.some(keyword => lower.includes(keyword));
    }
    
    /***********************
     * Utility Functions
     ***********************/
    function makeNonlinearCurve(amount = 3) {
      const samples = 1024;
      const curve = new Float32Array(samples);
      for (let i = 0; i < samples; i++) {
        let x = (i * 2) / samples - 1;
        curve[i] = Math.sign(x) * Math.pow(Math.abs(x), amount);
      }
      return curve;
    }
    function randomChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function generateDynamicLocation() {
      const directions = ["northern", "southern", "eastern", "western", "central"];
      const locationTypes = ["corridor", "sector", "grid", "zone", "range"];
      const direction = randomChoice(directions);
      const type = randomChoice(locationTypes);
      if (["sector", "zone", "corridor", "range"].includes(type)) {
        let number = Math.floor(Math.random() * 10) + 1;
        return `${direction} ${type} ${number}`;
      } else if (type === "grid") {
        let number = Math.floor(Math.random() * 10) + 1;
        let letter = randomChoice("ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(''));
        return `grid ${number}${letter}`;
      } else { return `${direction} ${type}`; }
    }
    
    /***********************
     * Environment & Day/Night Functions
     ***********************/
    function updateEnvironment() {
      const conditions = ["sunny", "clear", "cloudy", "rainy", "stormy", "hot", "cold", "windy", "foggy", "snowy"];
      environmentCondition = randomChoice(conditions);
      console.log("Environment updated to:", environmentCondition);
    }
    function getConditionRemark() {
      switch (environmentCondition) {
        case "sunny": return "with bright, glorious sunshine";
        case "clear": return "under clear skies";
        case "cloudy": return "under overcast skies";
        case "rainy": return "amid heavy rains";
        case "stormy": return "with a raging storm";
        case "hot": return "in scorching heat";
        case "cold": return "in freezing conditions";
        case "windy": return "as the wind howls";
        case "foggy": return "in thick fog";
        case "snowy": return "with falling snow";
        default: return "";
      }
    }
    function getDayNightRemark() { return (timeOfDay === "night") ? "under a starry sky" : "in bright daylight"; }
    function updateTimeOfDay() { timeOfDay = (timeOfDay === "day") ? "night" : "day"; console.log("Time of day updated to:", timeOfDay); }
    
    /***********************
     * Helper: Check for Unusual Keywords
     ***********************/
    function checkForUnusual(text) {
      const lower = text.toLowerCase();
      return lower.includes("unusual") || lower.includes("anomalous") ||
             lower.includes("erratic") || lower.includes("anomaly");
    }
    
    /***********************
     * Mood & Tone Functions
     ***********************/
    function updateMood(user) {
      let baseMood = user.baseMood || "calm";
      let newMood = baseMood;
      if (lastEventInfluence) {
        if (Math.random() < 0.7) { newMood = (lastEventInfluence === "critical") ? "agitated" : "reflective"; }
        lastEventInfluence = null;
      } else {
        if (Math.random() < 0.3) {
          switch (environmentCondition) {
            case "stormy":
            case "hot":
            case "windy":
              newMood = "agitated"; break;
            case "rainy":
            case "foggy":
            case "cold":
            case "snowy":
              newMood = "reflective"; break;
            case "sunny":
            case "clear":
              newMood = "calm"; break;
            default:
              newMood = baseMood; break;
          }
        }
      }
      user.mood = newMood;
      console.log(`${user.callSign} mood updated to ${user.mood} (Base: ${baseMood}, Env: ${environmentCondition})`);
    }
    function getMoodPrefix(mood) {
      switch(mood) {
        case "agitated": return "Quick update: ";
        case "reflective": return "Just thinking: ";
        case "surprised": return "Whoa, ";
        default: return "";
      }
    }
    function getResponsePrefix(style) {
      if (style === "formal") return "Roger";
      else if (style === "casual") return "ten four";
      else return (Math.random() < 0.5) ? "Roger" : "ten four";
    }
    
    /***********************
     * Simulated Radio Users
     ***********************/
    const users = [
      { callSign: "Alpha",  pitch: 0.8, rate: 1.0, voice: null, broadcastChance: 0.2, style: "formal", mood: "calm", baseMood: "calm" },
      { callSign: "Bravo",  pitch: 1.2, rate: 1.1, voice: null, broadcastChance: 0.7, style: "casual", mood: "agitated", baseMood: "agitated" },
      { callSign: "Charlie", pitch: 0.9, rate: 0.9, voice: null, broadcastChance: 0.3, style: "mixed", mood: "reflective", baseMood: "reflective" }
    ];
    
    /***********************
     * Dialogue Libraries
     ***********************/
    const formalObservations = [
      "our analysis indicates unusual activity",
      "intel confirms a pattern of erratic signals",
      "surveillance reports reveal increased communication",
      "our sensors have detected anomalous readings",
      "recon data suggests a shift in overall activity"
    ];
    const extraFormalObservations = [
      "recent data suggests a gradual change in conditions",
      "sensors are picking up subtle fluctuations",
      "the latest readings hint at evolving patterns",
      "preliminary reports indicate irregular behavior"
    ];
    const normalObservations = [
      "all systems appear nominal",
      "everything is functioning within expected parameters",
      "operations continue as scheduled",
      "routine checks are in order"
    ];
    const banterStarters = ["Hey", "Yo", "Listen up", "Check it out", "Heads up"];
    const banterRemarks = [
      "the situation is a bit odd",
      "I noticed something unusual",
      "there's a lot going on",
      "things are definitely shifting",
      "that action was unexpected"
    ];
    const extraBanter = [
      "This is off the charts!",
      "You won't believe what's happening!",
      "It's like nothing I've heard before.",
      "Absolutely wild!"
    ];
    const unscriptedMessages = [
      "Man, things are off today.",
      "I don't even know what to say.",
      "This is just crazy.",
      "What the heck is going on?",
      "Seriously, can you believe it?",
      "No comment."
    ];
    const extraUnscripted = [
      "I'm speechless.",
      "There's something in the air today.",
      "Not sure what's happening here."
    ];
    const complaints = [
      "This equipment is really letting me down.",
      "I can't believe how unreliable these signals are.",
      "Our systems just aren't performing as expected."
    ];
    const updates = [
      "All systems are operational.",
      "Routine check complete.",
      "Everything is running smoothly."
    ];
    const allUnscriptedAssets = unscriptedMessages.concat(extraUnscripted, complaints, updates);
    
    // Expanded conversation topics.
    const conversationTopics = {
      weather: {
        initial: [
          "The weather's been really strange today—overcast with an unexpected chill.",
          "I'm noticing a gloomy sky and a persistent chill. It's unusual."
        ],
        branchA: [
          "I think a storm might be brewing; the clouds are darkening.",
          "The skies are looking ominous—might be a storm soon."
        ],
        branchB: [
          "At least the cool weather is keeping things calm.",
          "Even with the chill, the weather seems stable."
        ],
        chain: [
          "The chill is growing stronger, and the clouds are thickening.",
          "I can sense a gradual change in the weather.",
          "It looks like the temperature is dropping further."
        ]
      },
      equipment: {
        initial: [
          "My gear seems to be acting up; the signal is a bit fuzzy today.",
          "I've noticed some interference with my equipment."
        ],
        branchA: [
          "Maybe it's time for a quick maintenance check.",
          "I think my equipment might need a tune-up soon."
        ],
        branchB: [
          "Is anyone else noticing issues with their gear?",
          "My equipment's been a bit unpredictable—could be a minor fault."
        ],
        chain: [
          "The static in my gear is intensifying.",
          "I'm noticing more interference than usual.",
          "It might be time for a quick check on my equipment."
        ]
      },
      operations: {
        initial: [
          "There's been a noticeable shift in overall activity.",
          "Communications seem a bit off today."
        ],
        branchA: [
          "I wonder if we're seeing a subtle change in our routine.",
          "The current activity doesn't quite match our usual patterns."
        ],
        branchB: [
          "It might just be a temporary fluctuation.",
          "These changes could be nothing—but it's worth noting."
        ],
        chain: [
          "The flow of transmissions is gradually changing.",
          "I'm sensing a subtle shift in our usual patterns.",
          "There’s something different in the air today."
        ]
      },
      humorous: {
        initial: [
          "Well, that's one for the books!",
          "You won't believe the stuff coming through today!"
        ],
        branchA: [
          "Sometimes, I swear my radio has a mind of its own.",
          "I think these frequencies are just messing with me."
        ],
        branchB: [
          "This is absurd—but it’s oddly entertaining.",
          "Not every day you get such a bizarre update, huh?"
        ],
        chain: [
          "I can't help but chuckle at how unpredictable this is.",
          "Sometimes the chatter is so offbeat, it's almost comical.",
          "Who knew radio transmissions could be this funny?"
        ]
      },
      reflective: {
        initial: [
          "It's been a long day; I'm taking a moment to reflect.",
          "Some transmissions really make you ponder the bigger picture."
        ],
        branchA: [
          "I can't shake the feeling there's more beneath the surface.",
          "The quiet moments between messages speak volumes."
        ],
        branchB: [
          "Every transmission feels like a fragment of a larger story.",
          "There's a calm introspection in all this chatter."
        ],
        chain: [
          "I'm left thinking about what these messages truly mean.",
          "Sometimes, the silence is as meaningful as the words.",
          "I find myself reflecting on the subtle shifts in our chatter."
        ]
      },
      maintenance: {
        initial: [
          "It seems some of our equipment might be due for servicing.",
          "I noticed a few glitches in the systems today."
        ],
        branchA: [
          "Maybe we should schedule a maintenance check soon.",
          "A quick tune-up could solve these issues."
        ],
        branchB: [
          "Anyone else experiencing similar issues with their gear?",
          "My instruments have been a bit off—could be routine wear."
        ],
        chain: [
          "The equipment's performance seems to be declining.",
          "I'm noticing more frequent glitches in the readings.",
          "It might be time to look over our systems."
        ]
      },
      navigation: {
        initial: [
          "I'm having some trouble with the navigation systems today.",
          "The positional data seems a bit off."
        ],
        branchA: [
          "Perhaps we need to recalibrate our instruments.",
          "A quick check of our navigation might be in order."
        ],
        branchB: [
          "Is anyone else getting questionable coordinates?",
          "The data on our current location seems inconsistent."
        ],
        chain: [
          "The navigation readings are becoming less reliable.",
          "I'm noticing discrepancies in our coordinates.",
          "It might be time for a recalibration."
        ]
      },
      logistics: {
        initial: [
          "Our supply lines seem to be running low on critical resources.",
          "Logistics reports indicate delays in resupply."
        ],
        branchA: [
          "Maybe we should review our supply routes.",
          "It might be time to reroute our logistics."
        ],
        branchB: [
          "Our resupply efforts are facing unexpected delays.",
          "The current logistics situation is less than ideal."
        ],
        chain: [
          "Further delays in resupply are expected.",
          "The logistics situation is deteriorating.",
          "We may need to adjust our supply strategy."
        ]
      },
      security: {
        initial: [
          "There have been unusual movements near the perimeter.",
          "Sensors are detecting potential security breaches."
        ],
        branchA: [
          "We should be on high alert.",
          "Prepare for potential intrusions."
        ],
        branchB: [
          "All clear, but stay vigilant.",
          "No immediate threats, but remain cautious."
        ],
        chain: [
          "Security status is being monitored closely.",
          "We are maintaining a heightened state of alert.",
          "All units, be prepared for unexpected developments."
        ]
      },
      morale: {
        initial: [
          "Morale is high today; everyone seems upbeat.",
          "The team is feeling positive and energized."
        ],
        branchA: [
          "Let's keep this momentum going.",
          "We should capitalize on this positive energy."
        ],
        branchB: [
          "It's great to see everyone so motivated.",
          "The vibe is incredible; let's ride this wave."
        ],
        chain: [
          "I still feel that spark from our earlier briefing.",
          "The enthusiasm is contagious, isn't it?",
          "We should celebrate this surge in morale."
        ]
      },
      // New casual topic: "chitchat"
      chitchat: {
        initial: [
          "Hey, what's up?",
          "Just checking in—how's everyone doing?",
          "Anyone got any fun news?"
        ],
        branchA: [
          "I've been wondering, what's new with you all?",
          "Any interesting stories today?"
        ],
        branchB: [
          "I had the weirdest experience on my way here.",
          "Sometimes it's good to just chat about nothing in particular."
        ],
        chain: [
          "Just sharing some thoughts here.",
          "It's the little things that make the day interesting.",
          "Sometimes, casual chit-chat is all you need."
        ]
      }
    };
    
    /***********************
     * Scripted Events
     ***********************/
    const scriptedEvents = [
      "All units, please standby for an update.",
      "Attention all stations: an important update is incoming.",
      "NEWS FLASH: please prepare for further instructions."
    ];
    const extraScriptedEvents = [
      "Stand by for a system update.",
      "Attention: All units, a new directive will be issued shortly.",
      "Breaking news: further instructions will follow."
    ];
    const allScriptedEvents = scriptedEvents.concat(extraScriptedEvents);
    
    /***********************
     * Voice Assignment Routine (Platform Check)
     ***********************/
    function assignPreferredVoices() {
      let platform = "unknown";
      const ua = navigator.userAgent;
      if (/Android/i.test(ua)) { platform = "android"; }
      else if (/iPhone|iPad|iPod/i.test(ua)) { platform = "ios"; }
      else if (/Macintosh/i.test(ua)) { platform = "mac"; }
      console.log("Platform detected:", platform);
      
      users.forEach((user, index) => {
        let voice = null;
        if (platform === "ios") {
          // Instead of always choosing "Samantha", filter for all English voices.
          let iosVoices = availableVoices.filter(v => v.lang.startsWith("en"));
          if (iosVoices.length > 0) {
            // Assign voices in round-robin fashion.
            voice = iosVoices[index % iosVoices.length];
          } else {
            voice = availableVoices[index % availableVoices.length];
          }
        } else if (platform === "android") {
          // Use voices that include "Google"
          voice = availableVoices.find(v => v.name.includes("Google"));
        } else if (platform === "mac") {
          // On mac, try "Alex" or "Samantha"
          voice = availableVoices.find(v => v.name === "Alex") || availableVoices.find(v => v.name === "Samantha");
        }
        if (!voice) { voice = availableVoices[index % availableVoices.length]; }
        user.voice = voice;
        console.log(`Assigned ${user.callSign} voice: ${user.voice.name}`);
      });
      updateStatus(`Voices assigned for platform: ${platform}.`);
    }
    
    function assignUserVoices() {
      availableVoices = window.speechSynthesis.getVoices();
      if (availableVoices.length === 0) {
        updateStatus("No voices available. Waiting for voiceschanged event.");
        window.speechSynthesis.onvoiceschanged = () => {
          availableVoices = window.speechSynthesis.getVoices();
          assignPreferredVoices();
        };
      } else { assignPreferredVoices(); }
    }
    
    /***********************
     * Dialogue Generation Functions
     ***********************/
    function generateStandardMessage(sender, forcedReceiver) {
      let style = (sender.style === "mixed")
                  ? (Math.random() < 0.5 ? "formal" : "casual")
                  : sender.style;
      let moodPrefix = (sender.mood !== "calm") ? getMoodPrefix(sender.mood) : "";
      const location = generateDynamicLocation();
      
      if (forcedReceiver) {
        let opener = (Math.random() < 0.5)
          ? randomChoice(["In response,", "Regarding that,", "About that,"]) + " "
          : "";
        let prefix = getResponsePrefix(style);
        if (style === "formal") {
          let observation;
          if (Math.random() < 0.3) {
            observation = randomChoice(extraFormalObservations);
          } else {
            observation = (environmentCondition === "clear" || environmentCondition === "sunny")
                          ? randomChoice(normalObservations)
                          : randomChoice(formalObservations);
          }
          if (checkForUnusual(observation)) {
            unusualChainState = "query";
            console.log("Unusual chain triggered in forced message (formal).");
          }
          if (checkForTrigger(observation)) {
            triggeredChain = true;
            chainCounter = 1;
            console.log("Triggered chain activated in forced message (formal).");
          }
          if (!(environmentCondition === "clear" || environmentCondition === "sunny")) {
            let conditionRemark = getConditionRemark();
            if (conditionRemark !== "") { observation += ", " + conditionRemark; }
          }
          observation += ", " + getDayNightRemark();
          return `${sender.callSign} to ${forcedReceiver.callSign}: ${opener}${moodPrefix}${prefix}, ${observation} ${location}. Over.`;
        } else {
          let starter = (Math.random() < 0.3) ? randomChoice(extraBanter) : randomChoice(banterStarters);
          let remark = randomChoice(banterRemarks);
          if (!banterChainActive && Math.random() < 0.7) {
            banterChainActive = true;
            banterChainCounter = 1;
            console.log("Banter chain triggered in forced message (casual).");
          }
          return `${sender.callSign} to ${forcedReceiver.callSign}: ${opener}${moodPrefix}${prefix}, ${starter} – ${remark}. Over.`;
        }
      } else {
        let isBroadcast = Math.random() < sender.broadcastChance;
        if (isBroadcast) {
          if (style === "formal") {
            let observation;
            if (Math.random() < 0.3) { observation = randomChoice(extraFormalObservations); }
            else { observation = (environmentCondition === "clear" || environmentCondition === "sunny")
                          ? randomChoice(normalObservations)
                          : randomChoice(formalObservations); }
            if (checkForUnusual(observation)) {
              unusualChainState = "query";
              console.log("Unusual chain triggered in broadcast message (formal).");
            }
            if (checkForTrigger(observation)) {
              triggeredChain = true;
              chainCounter = 1;
              console.log("Triggered chain activated in broadcast message (formal).");
            }
            if (!(environmentCondition === "clear" || environmentCondition === "sunny")) {
              let conditionRemark = getConditionRemark();
              if (conditionRemark !== "") { observation += ", " + conditionRemark; }
            }
            observation += ", " + getDayNightRemark();
            return `${sender.callSign} to all units: ${moodPrefix}${observation} ${location}. Over.`;
          } else {
            let starter = randomChoice(banterStarters);
            let remark = randomChoice(banterRemarks);
            return `${sender.callSign} to all units: ${moodPrefix}${starter} – ${remark}. Over.`;
          }
        } else {
          let potentialReceivers = users.filter(u => u.callSign !== sender.callSign);
          let receiver = randomChoice(potentialReceivers);
          if (style === "formal") {
            let observation;
            if (Math.random() < 0.3) { observation = randomChoice(extraFormalObservations); }
            else { observation = (environmentCondition === "clear" || environmentCondition === "sunny")
                          ? randomChoice(normalObservations)
                          : randomChoice(formalObservations); }
            if (checkForUnusual(observation)) {
              unusualChainState = "query";
              console.log("Unusual chain triggered in personal message (formal).");
            }
            if (checkForTrigger(observation)) {
              triggeredChain = true;
              chainCounter = 1;
              console.log("Triggered chain activated in personal message (formal).");
            }
            if (!(environmentCondition === "clear" || environmentCondition === "sunny")) {
              let conditionRemark = getConditionRemark();
              if (conditionRemark !== "") { observation += ", " + conditionRemark; }
            }
            observation += ", " + getDayNightRemark();
            return `${sender.callSign} to ${receiver.callSign}: ${moodPrefix}${observation} ${location}. Over.`;
          } else {
            let starter = randomChoice(banterStarters);
            let remark = randomChoice(banterRemarks);
            return `${sender.callSign} to ${receiver.callSign}: ${moodPrefix}${starter} – ${remark}. Over.`;
          }
        }
      }
    }
    
    function generateConversationChainMessage(sender, forcedReceiver) {
      // Initialize activeConversation if needed.
      if (!activeConversation) {
        activeConversation = {
          topic: randomChoice(Object.keys(conversationTopics)),
          lastSpeaker: sender.callSign,
          count: 0
        };
        console.log("Active conversation initialized with topic:", activeConversation.topic);
      }
      
      let template;
      // Priority order: triggered chain > banter chain > unusual chain > normal conversation.
      if (triggeredChain) {
        template = (chainCounter % 2 === 1)
          ? randomChoice(triggeredChainQueries)
          : randomChoice(triggeredChainExplanations);
        chainCounter++;
        console.log("Using triggered chain template:", template);
        if (chainCounter > maxChainDepth) {
          triggeredChain = false;
          chainCounter = 0;
          console.log("Triggered chain reset (max depth reached).");
        }
      }
      else if (banterChainActive) {
        template = (banterChainCounter % 2 === 1)
          ? randomChoice(banterChainQueries)
          : randomChoice(banterChainExplanations);
        banterChainCounter++;
        console.log("Using banter chain template:", template);
        if (banterChainCounter > maxBanterChainDepth) {
          banterChainActive = false;
          banterChainCounter = 0;
          console.log("Banter chain reset (max depth reached).");
        }
      }
      else if (unusualChainState !== null) {
        template = (unusualChainState === "query")
          ? randomChoice(unusualQueries)
          : randomChoice(unusualExplanations);
        unusualChainState = (unusualChainState === "query") ? "explanation" : "query";
        console.log("Using unusual chain template:", template);
      }
      else {
        let topic = activeConversation.topic;
        let branchChoice = Math.random();
        if (branchChoice < 0.33) { template = randomChoice(conversationTopics[topic].initial); }
        else if (branchChoice < 0.66) { template = randomChoice(conversationTopics[topic].branchA); }
        else { template = randomChoice(conversationTopics[topic].branchB); }
      }
      let opener = (Math.random() < 0.5)
        ? randomChoice(["In response,", "Regarding that,", "About that,"]) + " "
        : "";
      let style = (sender.style === "mixed")
                  ? (Math.random() < 0.5 ? "formal" : "casual")
                  : sender.style;
      let prefix = getResponsePrefix(style);
      if (style === "formal") {
        let conditionRemark = getConditionRemark();
        if (conditionRemark !== "") { template += ", " + conditionRemark; }
      }
      activeConversation.lastSpeaker = sender.callSign;
      activeConversation.count++;
      if (activeConversation.count >= 5) { activeConversation = null; }
      return `${sender.callSign} to ${forcedReceiver.callSign}: ${opener}${getMoodPrefix(sender.mood)}${prefix}, ${template} Over.`;
    }
    
    function generateUnscriptedMessage(sender) {
      let msg = randomChoice(allUnscriptedAssets);
      if (Math.random() < 0.5) { msg = `${sender.callSign}: ${msg}`; }
      return msg;
    }
    
    function generateMessage(sender, forcedReceiver) {
      // For forced (direct) replies:
      if (forcedReceiver) {
        if (sender.style !== "formal" && !banterChainActive && Math.random() < 0.7) {
          banterChainActive = true;
          banterChainCounter = 1;
          console.log("Banter chain triggered in forced message (casual).");
        }
        if (activeConversation || banterChainActive || triggeredChain || unusualChainState !== null) {
          console.log("Forced reply using chain response.");
          console.log("In reply from last tx from " + lastMessage.sender.callSign);
          return generateConversationChainMessage(sender, forcedReceiver);
        }
      }
      
      let unscriptedChance = forcedReceiver ? 0.1 : 0.3;
      if (Math.random() < unscriptedChance) { return generateUnscriptedMessage(sender); }
      
      updateMood(sender);
      
      if (!forcedReceiver && !activeConversation && Math.random() < 0.2) {
        let topics = Object.keys(conversationTopics);
        let chosenTopic = randomChoice(topics);
        activeConversation = { topic: chosenTopic, lastSpeaker: sender.callSign, count: 1 };
        let template = randomChoice(conversationTopics[chosenTopic].initial);
        return `${sender.callSign}: ${getMoodPrefix(sender.mood)}${template}`;
      }
      
      return generateStandardMessage(sender, forcedReceiver);
    }
    
    /***********************
     * Audio & Interference Functions
     ***********************/
    function playCharacterNoise(user) {
      if (!audioCtx) { const AudioContext = window.AudioContext || window.webkitAudioContext; audioCtx = new AudioContext(); }
      // Increase the duration to 10 seconds to help avoid gaps on iOS.
      const duration = 10, sampleRate = audioCtx.sampleRate, bufferSize = sampleRate * duration;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
      const noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = true;
      const filter = audioCtx.createBiquadFilter();
      if (user.callSign === "Alpha") { filter.type = "lowpass"; filter.frequency.setValueAtTime(500, audioCtx.currentTime); }
      else if (user.callSign === "Bravo") { filter.type = "bandpass"; filter.frequency.setValueAtTime(2000, audioCtx.currentTime); filter.Q.setValueAtTime(1.0, audioCtx.currentTime); }
      else if (user.callSign === "Charlie") { filter.type = "highpass"; filter.frequency.setValueAtTime(1500, audioCtx.currentTime); }
      else { filter.type = "bandpass"; filter.frequency.setValueAtTime(1000, audioCtx.currentTime); }
      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      noiseSource.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      noiseSource.start();
      return noiseSource;
    }
    
    function playCommBlip() {
      if (!audioCtx) return;
      const blipOsc = audioCtx.createOscillator(), blipGain = audioCtx.createGain();
      blipOsc.frequency.setValueAtTime(1200, audioCtx.currentTime);
      blipGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      blipOsc.connect(blipGain);
      blipGain.connect(audioCtx.destination);
      blipOsc.start();
      blipGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      blipOsc.stop(audioCtx.currentTime + 0.15);
    }
    
    function startInterference() {
      if (!audioCtx) { const AudioContext = window.AudioContext || window.webkitAudioContext; audioCtx = new AudioContext(); }
      // Increase noise buffer duration to 10 seconds for longer continuous noise.
      const sampleRate = audioCtx.sampleRate, bufferSize = sampleRate * 10;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
      basicNoiseSource = audioCtx.createBufferSource();
      basicNoiseSource.buffer = noiseBuffer;
      basicNoiseSource.loop = true;
      const basicFilter = audioCtx.createBiquadFilter();
      basicFilter.type = "bandpass";
      basicFilter.frequency.setValueAtTime(3000, audioCtx.currentTime);
      basicFilter.Q.setValueAtTime(1, audioCtx.currentTime);
      const basicGain = audioCtx.createGain();
      basicGain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      basicNoiseSource.connect(basicFilter);
      basicFilter.connect(basicGain);
      basicGain.connect(audioCtx.destination);
      basicNoiseSource.start();
      
      advancedNoiseSource = audioCtx.createBufferSource();
      advancedNoiseSource.buffer = noiseBuffer;
      advancedNoiseSource.loop = true;
      const advancedFilter = audioCtx.createBiquadFilter();
      advancedFilter.type = "bandpass";
      advancedFilter.frequency.setValueAtTime(2500, audioCtx.currentTime);
      advancedFilter.Q.setValueAtTime(1.5, audioCtx.currentTime);
      const advancedGain = audioCtx.createGain();
      advancedGain.gain.setValueAtTime(0.05, audioCtx.currentTime);
      lfo = audioCtx.createOscillator();
      lfo.frequency.setValueAtTime(0.5, audioCtx.currentTime);
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.setValueAtTime(0.03, audioCtx.currentTime);
      const nonLinearShaper = audioCtx.createWaveShaper();
      nonLinearShaper.curve = makeNonlinearCurve(3);
      nonLinearShaper.oversample = '4x';
      lfo.connect(lfoGain);
      lfoGain.connect(nonLinearShaper);
      nonLinearShaper.connect(advancedGain.gain);
      lfo.start();
      advancedNoiseSource.connect(advancedFilter);
      advancedFilter.connect(advancedGain);
      advancedGain.connect(audioCtx.destination);
      advancedNoiseSource.start();
    }
    
    function triggerBurstInterference() {
      if (!audioCtx) return;
      const burstDuration = 0.1, sampleRate = audioCtx.sampleRate;
      const burstBuffer = audioCtx.createBuffer(1, sampleRate * burstDuration, sampleRate);
      const burstData = burstBuffer.getChannelData(0);
      for (let i = 0; i < burstBuffer.length; i++) { burstData[i] = Math.random() * 2 - 1; }
      const burstSource = audioCtx.createBufferSource();
      burstSource.buffer = burstBuffer;
      const burstGain = audioCtx.createGain();
      burstGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      burstGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + burstDuration);
      const burstFilter = audioCtx.createBiquadFilter();
      burstFilter.type = "highpass";
      burstFilter.frequency.setValueAtTime(2000, audioCtx.currentTime);
      burstSource.connect(burstFilter);
      burstFilter.connect(burstGain);
      burstGain.connect(audioCtx.destination);
      burstSource.start();
      burstSource.stop(audioCtx.currentTime + burstDuration);
    }
    
    function scheduleBurstInterference() {
      if (!simulationRunning) return;
      const burstInterval = Math.random() * 3000 + 2000;
      burstInterferenceTimer = setTimeout(() => { triggerBurstInterference(); scheduleBurstInterference(); }, burstInterval);
    }
    
    /***********************
     * Simulation Control Functions
     ***********************/
    function startSimulation() {
      if (simulationRunning) return;
      simulationRunning = true;
      console.log("Simulation starting...");
      
      const voices = window.speechSynthesis.getVoices();
      if (voices.length === 0) {
        updateStatus("Loading voices...");
        window.speechSynthesis.onvoiceschanged = () => {
          assignUserVoices();
          updateStatus("Voices loaded. Starting simulation...");
          simulateTransmission();
        };
      } else {
        assignUserVoices();
        updateStatus("Voices loaded. Starting simulation...");
        simulateTransmission();
      }
      
      startInterference();
      scheduleBurstInterference();
      setInterval(updateEnvironment, 60000);
      setInterval(updateTimeOfDay, 30000);
      
      setInterval(() => {
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().then(() => { console.log("Audio context resumed"); })
          .catch((err) => { console.error("Error resuming audio context:", err); });
        }
      }, 10000);
      
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().then(() => { console.log("Audio context resumed on visibility change"); });
        }
      });
    }
    
    function stopSimulation() {
      simulationRunning = false;
      window.speechSynthesis.cancel();
      updateStatus("Simulation stopped.");
      console.log("Simulation stopped.");
      
      if (basicNoiseSource) { try { basicNoiseSource.stop(); } catch(e) { console.error(e); } basicNoiseSource.disconnect(); basicNoiseSource = null; }
      if (advancedNoiseSource) { try { advancedNoiseSource.stop(); } catch(e) { console.error(e); } advancedNoiseSource.disconnect(); advancedNoiseSource = null; }
      if (lfo) { try { lfo.stop(); } catch(e) { console.error(e); } lfo.disconnect(); lfo = null; }
      if (burstInterferenceTimer) { clearTimeout(burstInterferenceTimer); burstInterferenceTimer = null; }
    }
    
    /***********************
     * UI Control Event Listeners
     ***********************/
    document.getElementById('startSim').addEventListener('click', startSimulation);
    document.getElementById('stopSim').addEventListener('click', stopSimulation);
    document.getElementById('clearLog').addEventListener('click', () => { document.getElementById('log').innerHTML = ""; });
    document.getElementById('delayMultiplier').addEventListener('input', (event) => { document.getElementById('multiplierValue').textContent = event.target.value; });
    
    /***********************
     * Transmission Simulation
     ***********************/
    function simulateTransmission() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        console.log("Audio context created.");
      }
      
      let sender, forcedReceiver = null;
      if (lastMessage && !lastMessage.broadcast && Math.random() < 0.7) {
        sender = lastMessage.receiver;
        forcedReceiver = lastMessage.sender;
        console.log(`Direct response: ${sender.callSign} replying to ${forcedReceiver.callSign}`);
        console.log("In reply from last tx from " + lastMessage.sender.callSign);
      } else {
        let possibleSenders = users;
        if (lastMessage) { possibleSenders = users.filter(u => u.callSign !== lastMessage.sender.callSign); }
        sender = randomChoice(possibleSenders);
        console.log(`New transmission from: ${sender.callSign}`);
      }
      
      if (!forcedReceiver && Math.random() < 0.1) {
        let eventMsg = randomChoice(allScriptedEvents);
        lastEventInfluence = randomChoice(["critical", "informative"]);
        const logDiv = document.getElementById('log');
        const p = document.createElement('p');
        p.textContent = eventMsg;
        logDiv.appendChild(p);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log("Scripted event triggered:", eventMsg);
        let eventDelay = 3000 * parseFloat(document.getElementById("delayMultiplier").value);
        setTimeout(() => { if (simulationRunning) simulateTransmission(); }, eventDelay);
        return;
      }
      
      let message = generateMessage(sender, forcedReceiver);
      let broadcast = message.includes("to all units:");
      console.log("Generated message:", message);
      
      const logDiv = document.getElementById('log');
      const p = document.createElement('p');
      p.textContent = message;
      // Apply custom text colors based on sender.
      if (sender.callSign === "Alpha") { p.classList.add("log-Alpha"); }
      else if (sender.callSign === "Bravo") { p.classList.add("log-Bravo"); }
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
      
      const utterance = new SpeechSynthesisUtterance(message);
      utterance.lang = 'en-US';
      utterance.pitch = sender.pitch;
      utterance.rate = sender.rate;
      if (sender.voice) { utterance.voice = sender.voice; }
      
      let charNoiseSource = null;
      utterance.onstart = function() {
        playCommBlip();
        charNoiseSource = playCharacterNoise(sender);
      };
      
      utterance.onend = function() {
        playCommBlip();
        if (charNoiseSource) {
          try { charNoiseSource.stop(); } catch(e) { console.error("Error stopping noise:", e); }
        }
        let multiplier = parseFloat(document.getElementById("delayMultiplier").value);
        let delay = (lastMessage && lastMessage.isResponse)
                    ? (Math.random() * (5000 - 3000) + 3000) * multiplier
                    : (Math.random() * (10000 - 6000) + 6000) * multiplier;
        console.log(`Next message in ${(delay / 1000).toFixed(1)} seconds (from end).`);
        setTimeout(() => { if (simulationRunning) simulateTransmission(); }, delay);
      };
      
      window.speechSynthesis.speak(utterance);
      
      let receiverObj;
      if (forcedReceiver) { receiverObj = forcedReceiver; }
      else if (broadcast) { receiverObj = { callSign: "all units" }; }
      else {
        let potentialReceivers = users.filter(u => u.callSign !== sender.callSign);
        receiverObj = randomChoice(potentialReceivers);
      }
      
      lastMessage = {
        sender: sender,
        receiver: receiverObj,
        broadcast: broadcast,
        message: message,
        isResponse: (forcedReceiver !== null)
      };
    }
    
  </script>
</body>
</html>
